---
globs: *.ts
alwaysApply: false
---
## GET Server Actions

These guidelines are specifically for **GET/READ** server actions that fetch data from Supabase.

Whenever you are tasked with creating a new **GET** Server Action file, use the following guideline/principles 

## Basic Requirements

* Always declare `"use server"` in the first line of every Server Action file.

* Always create a separate file for each server action in the following directory structure: `app/features/<feature-name>/actions/<action-name>.ts`

* Always import the Supabase client from `@/lib/supabase` and use it for database operations.

* **Validate input parameters with Zod** when accepting user input (IDs, filters, pagination).

## Zod Validation Protocol

Server-side validation is **recommended** for GET operations that accept user input. This prevents malformed queries and potential injection attacks.

### 1. Create Query Schemas for the Feature

Create schemas in the feature's lib folder: `app/features/<feature-name>/lib/<entity>.schema.ts`

```typescript
import { z } from "zod";
import messages from "@/lib/messages.json";

/**
 * Schema for validating IDs (used for single record fetches)
 */
export const getAmenityByIdSchema = z.object({
  id: z
    .number()
    .int(messages.amenities.validation.id.integer)
    .positive(messages.amenities.validation.id.positive),
});

/**
 * Schema for pagination parameters
 */
export const paginationSchema = z.object({
  page: z.number().int().positive().default(1),
  limit: z.number().int().min(1).max(100).default(20),
});

/**
 * Schema for filtering/searching
 */
export const amenitiesFilterSchema = z.object({
  search: z.string().max(100).optional(),
  minPrice: z.number().min(0).optional(),
  maxPrice: z.number().max(99_999.99).optional(),
});

export type GetAmenityByIdInput = z.infer<typeof getAmenityByIdSchema>;
export type PaginationInput = z.infer<typeof paginationSchema>;
export type AmenitiesFilterInput = z.infer<typeof amenitiesFilterSchema>;
```

### 2. When to Validate GET Operations

**Always validate:**
- IDs for single record fetches
- User-provided search/filter parameters
- Pagination parameters (page, limit)

**Skip validation for:**
- Simple "get all" queries with no parameters
- Internal queries with hardcoded parameters

### 3. Implementation Examples

**Simple GET (no validation needed):**
```typescript
"use server";

import { supabase } from "@/lib/supabase";
import { toSupabaseQueryResponse } from "@/lib/supabase-response";
import type { Tables } from "@/supabase/types/database";

export async function getAmenities() {
  const result = await supabase.from("amenities").select();
  return toSupabaseQueryResponse<Tables<"amenities">[]>(result);
}
```

**GET by ID (validate the ID):**
```typescript
"use server";

import { supabase } from "@/lib/supabase";
import { toSupabaseQueryResponse } from "@/lib/supabase-response";
import { createValidationError } from "@/lib/validation";
import type { Tables } from "@/supabase/types/database";
import { getAmenityByIdSchema } from "../lib/amenity.schema";

export async function getAmenityById(id: number) {
  // Validate ID
  const validationResult = getAmenityByIdSchema.safeParse({ id });
  if (!validationResult.success) {
    return {
      data: null,
      error: createValidationError(validationResult.error),
    };
  }

  const result = await supabase
    .from("amenities")
    .select()
    .eq("amenity_id", id)
    .single();

  return toSupabaseQueryResponse<Tables<"amenities">>(result);
}
```

**GET with pagination (validate pagination params):**
```typescript
"use server";

import { supabase } from "@/lib/supabase";
import { toSupabaseQueryResponse } from "@/lib/supabase-response";
import { createValidationError } from "@/lib/validation";
import type { Tables } from "@/supabase/types/database";
import { paginationSchema, type PaginationInput } from "../lib/amenity.schema";

export async function getAmenitiesPaginated(params: PaginationInput) {
  // Validate pagination params
  const validationResult = paginationSchema.safeParse(params);
  if (!validationResult.success) {
    return {
      data: null,
      error: createValidationError(validationResult.error),
    };
  }

  const { page, limit } = validationResult.data;
  const from = (page - 1) * limit;
  const to = from + limit - 1;

  const result = await supabase
    .from("amenities")
    .select()
    .range(from, to);

  return toSupabaseQueryResponse<Tables<"amenities">[]>(result);
}
```

**GET with filters (validate filter params):**
```typescript
"use server";

import { supabase } from "@/lib/supabase";
import { toSupabaseQueryResponse } from "@/lib/supabase-response";
import { createValidationError } from "@/lib/validation";
import type { Tables } from "@/supabase/types/database";
import { amenitiesFilterSchema, type AmenitiesFilterInput } from "../lib/amenity.schema";

export async function searchAmenities(filters: AmenitiesFilterInput) {
  // Validate filter params
  const validationResult = amenitiesFilterSchema.safeParse(filters);
  if (!validationResult.success) {
    return {
      data: null,
      error: createValidationError(validationResult.error),
    };
  }

  const { search, minPrice, maxPrice } = validationResult.data;

  let query = supabase.from("amenities").select();

  if (search) {
    query = query.ilike("amenity_name", `%${search}%`);
  }
  if (minPrice !== undefined) {
    query = query.gte("amenity_price", minPrice);
  }
  if (maxPrice !== undefined) {
    query = query.lte("amenity_price", maxPrice);
  }

  const result = await query;
  return toSupabaseQueryResponse<Tables<"amenities">[]>(result);
}
```

## Supabase Response Pattern

All server actions that interact with Supabase MUST use the standardized `SupabaseResponse<T>` pattern for type-safe, consistent error handling.

### Server Action Implementation

1. **Import required utilities:**
   ```typescript
   import { supabase } from "@/lib/supabase";
   import { toSupabaseQueryResponse } from "@/lib/supabase-response";
   import { createValidationError } from "@/lib/validation"; // Only if validating
   import type { Tables } from "@/supabase/types/database";
   ```

2. **Structure your server action:**
   ```typescript
   "use server";

   import { supabase } from "@/lib/supabase";
   import { toSupabaseQueryResponse } from "@/lib/supabase-response";
   import type { Tables } from "@/supabase/types/database";

   export async function getAmenities() {
     const result = await supabase.from("amenities").select();
     return toSupabaseQueryResponse<Tables<"amenities">[]>(result);
   }
   ```

3. **Key points:**
   - Always wrap Supabase query results with `toSupabaseQueryResponse<T>()`
   - Use `Tables<"table_name">` for single records or `Tables<"table_name">[]` for arrays
   - Validate user input with Zod when accepting IDs, filters, or pagination
   - Return the transformed response directly

### Using Server Actions in Pages (Server Components) with Suspense

1. **Call the server action WITHOUT awaiting (for streaming):**
   ```typescript
   import { Suspense } from "react";
   import { getAmenities } from "@/app/features/amenities/actions/get-amenities";
   import AmenitiesList from "@/app/features/amenities/components/amenities-list";
   import AmenitiesListSkeleton from "@/app/features/amenities/components/amenities-list-skeleton";

   export default function Home() {
     // Don't await - pass the Promise to enable streaming
     const amenitiesPromise = getAmenities();
     
     return (
       <div>
         <h1>The Social House</h1>
         {/* Suspense boundary enables streaming - static content renders immediately */}
         <Suspense fallback={<AmenitiesListSkeleton />}>
           <AmenitiesList promise={amenitiesPromise} />
         </Suspense>
       </div>
     );
   }
   ```

2. **Key points:**
   - **Don't await** the server action - pass the Promise directly to enable streaming
   - Use React's `use()` hook in client components to unwrap the Promise
   - Create loading skeleton components for better UX (not just "Loading...")
   - Suspense boundaries enable progressive streaming - static content renders immediately
   - Multiple Suspense boundaries can be used for independent loading sections

### Handling Responses in Components with Suspense

1. **Create a loading skeleton component:**
   ```typescript
   // app/features/amenities/components/amenities-list-skeleton.tsx
   import { Skeleton } from "@/components/ui/skeleton";

   export default function AmenitiesListSkeleton() {
     return (
       <div className="space-y-4">
         {[1, 2, 3].map((i) => (
           <div key={i} className="space-y-2">
             <Skeleton className="h-6 w-48" />
             <Skeleton className="h-4 w-24" />
           </div>
         ))}
       </div>
     );
   }
   ```

2. **Create the component that uses React's `use()` hook:**
   ```typescript
   "use client";

   import { use } from "react";
   import type { SupabaseResponse } from "@/lib/supabase-response";
   import { hasData, hasError } from "@/lib/supabase-response";
   import type { Tables } from "@/supabase/types/database";

   type ComponentProps = {
     promise: Promise<SupabaseResponse<Tables<"amenities">[]>>;
   };

   export default function Component({ promise }: ComponentProps) {
     // use() hook unwraps the Promise and triggers Suspense
     const result = use(promise);

     // Check for errors first (including validation errors)
     if (hasError(result)) {
       return <div>Error: {result.error.message}</div>;
     }

     // TypeScript now knows result.data exists and is not null
     if (!hasData(result) || result.data.length === 0) {
       return <div>No data found</div>;
     }

     // Safe to use result.data - TypeScript has narrowed the type
     return (
       <div>
         {result.data.map((item) => (
           <div key={item.id}>{item.name}</div>
         ))}
       </div>
     );
   }
   ```

3. **Key points:**
   - Component must be a **client component** (`"use client"`) to use `use()` hook
   - Use React's `use()` hook to unwrap Promises - this triggers Suspense
   - Always use `hasError()` and `hasData()` type guards for type-safe handling
   - Check errors before checking data (handles both validation and query errors)
   - TypeScript automatically narrows types after using the guards
   - Create skeleton components that match your content structure for better UX
   - The `use()` hook will suspend the component until the Promise resolves

### Error Handling for GET Operations

1. **Common error codes:**
   - `VALIDATION_ERROR` - Zod validation failed (invalid ID, filter params, etc.)
   - `PGRST116` - No rows returned (record not found with `.single()`)

2. **Error handling in components:**
   ```typescript
   if (hasError(result)) {
     // Handle both validation errors and query errors
     if (result.error.code === "VALIDATION_ERROR") {
       return <div>Invalid request: {result.error.message}</div>;
     }
     if (result.error.code === "PGRST116") {
       return <div>Record not found</div>;
     }
     return <div>Error: {result.error.message}</div>;
   }
   ```

## Benefits

* **Secure**: Input validation prevents malformed queries and injection attacks
* **Type-safe**: TypeScript automatically narrows types with `hasData()` and `hasError()`
* **Consistent**: Same pattern across all server actions
* **Reusable**: `toSupabaseQueryResponse()` works with any Supabase query
* **Clean**: No need for custom response types per action
