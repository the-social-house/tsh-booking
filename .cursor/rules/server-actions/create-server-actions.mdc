---
globs: *.ts
alwaysApply: false
---
## CREATE Server Actions

These guidelines are specifically for **CREATE/INSERT** server actions that create new records in Supabase.

Whenever you are tasked with creating a new **CREATE** Server Action file, use the following guideline/principles

## Basic Requirements

* Always declare `"use server"` in the first line of every Server Action file.

* Always create a separate file for each server action in the following directory structure: `app/features/<feature-name>/actions/create-<entity-name>.ts`

* **Always use `requireAuth()` or `requireAdmin()`** for authentication and to get the Supabase client.

* **Always validate input with Zod** before performing database operations.

## Authentication Protocol

All CREATE server actions MUST verify authentication before performing any database operations.

### 1. Import and Use Auth Helpers

```typescript
import { requireAuth } from "@/app/features/auth/lib/require-auth";
// OR for admin-only actions:
import { requireAdmin } from "@/app/features/auth/lib/require-admin";
```

### 2. Authentication Check Pattern

```typescript
export async function createEntity(data: CreateEntityInput) {
  // 1. Verify authentication and get Supabase client (ALWAYS first)
  const { supabase, error: authError } = await requireAuth();
  if (authError || !supabase) {
    return {
      data: null,
      error: authError || {
        code: "UNAUTHENTICATED",
        message: "You must be logged in to perform this action",
        details: "",
        hint: "",
        name: "AuthError",
      },
    };
  }

  // 2. Validate input with Zod
  // 3. Perform database operation using the returned supabase client
  // ...
}
```

### 3. Key Points

- **`requireAuth()`** returns `{ user, supabase, error }` - use for user actions
- **`requireAdmin()`** returns `{ user, supabase, error }` - use for admin-only actions
- **Reuse the returned `supabase` client** - don't create a new one
- **Auth check comes BEFORE validation** - no point validating if user isn't authenticated
- **One Supabase client per request** - efficient connection pooling

## Zod Validation Protocol

Server-side validation is **mandatory** for all CREATE operations. Follow these steps:

### 1. Create a Schema File for the Feature

Create schemas in the feature's lib folder: `app/features/<feature-name>/lib/<entity>.schema.ts`

```typescript
import { z } from "zod";
import messages from "@/lib/messages.json";

/**
 * Schema for creating a new amenity
 */
export const createAmenitySchema = z.object({
  amenity_name: z
    .string()
    .min(1, messages.amenities.validation.name.required)
    .min(2, messages.amenities.validation.name.minLength)
    .max(100, messages.amenities.validation.name.maxLength)
    .trim(),
  amenity_price: z
    .number()
    .min(0, messages.amenities.validation.price.min)
    .max(99_999.99, messages.amenities.validation.price.max)
    .nullable()
    .optional(),
});

export type CreateAmenityInput = z.infer<typeof createAmenitySchema>;
```

**Key points for schemas:**
- Import validation messages from `@/lib/messages.json` for user-friendly errors
- Use `.trim()` on string fields to remove whitespace
- Use `.nullable().optional()` for optional fields
- Export both the schema and the inferred type
- Match validation rules to database constraints

### 2. Use the Shared Validation Helper

The `@/lib/validation.ts` file provides reusable validation utilities:

```typescript
import type { z } from "zod";

/**
 * Format Zod validation errors into a user-friendly message
 */
export function formatZodErrors(error: z.ZodError): string {
  return error.issues.map((issue) => issue.message).join(". ");
}

/**
 * Create a validation error response compatible with PostgrestError
 */
export function createValidationError(error: z.ZodError) {
  return {
    code: "VALIDATION_ERROR",
    message: formatZodErrors(error),
    details: JSON.stringify(error.issues),
    hint: "",
    name: "ValidationError",
  };
}
```

### 3. Implement Authentication and Validation in Server Action

```typescript
"use server";

import { requireAuth } from "@/app/features/auth/lib/require-auth";
import { toSupabaseMutationResponse } from "@/lib/supabase-response";
import { createValidationError } from "@/lib/validation";
import type { Tables } from "@/supabase/types/database";
import {
  type CreateAmenityInput,
  createAmenitySchema,
} from "../lib/amenity.schema";
import { getCreateErrorMessage } from "../lib/error-messages";

export async function createAmenity(data: CreateAmenityInput) {
  // 1. Verify authentication and get Supabase client (ALWAYS first)
  const { supabase, error: authError } = await requireAuth();
  if (authError || !supabase) {
    return {
      data: null,
      error: authError || {
        code: "UNAUTHENTICATED",
        message: "You must be logged in to create an amenity",
        details: "",
        hint: "",
        name: "AuthError",
      },
    };
  }

  // 2. Validate input with Zod
  const validationResult = createAmenitySchema.safeParse(data);
  if (!validationResult.success) {
    return {
      data: null,
      error: createValidationError(validationResult.error),
    };
  }

  // 3. Use validated data for database operation
  const validatedData = validationResult.data;

  const result = await supabase
    .from("amenities")
    .insert(validatedData)
    .select()
    .single();

  // 4. Handle database errors with user-friendly messages
  if (result.error) {
    const errorMessage = getCreateErrorMessage(result.error.code);
    return {
      data: null,
      error: { ...result.error, message: errorMessage },
    };
  }

  return toSupabaseMutationResponse<Tables<"amenities">>(result);
}
```

## Supabase Response Pattern for CREATE Operations

Supabase INSERT operations return `{ data, error, status, statusText }` where:
- `data` contains the inserted record(s) **ONLY if** `.select()` is used
- `data` is `null` if `.select()` is **NOT** used (even on successful insert)
- `error` is `null` on success, or a `PostgrestError` on failure
- `status` and `statusText` are HTTP response properties (e.g., `status: 201, statusText: "Created"`)

**Choose based on your use case:**
- **With `.select()`**: Returns the created record(s) - use when you need the data immediately (e.g., to display in UI, get generated IDs)
- **Without `.select()`**: Returns success/failure only - use when you don't need the created data back (e.g., bulk operations, fire-and-forget)

### Server Action Implementation

1. **Import required utilities:**
   ```typescript
   import { requireAuth } from "@/app/features/auth/lib/require-auth";
   // OR for admin-only actions:
   import { requireAdmin } from "@/app/features/auth/lib/require-admin";
   import { toSupabaseMutationResponse } from "@/lib/supabase-response";
   import { createValidationError } from "@/lib/validation";
   import type { Tables } from "@/supabase/types/database";
   import { type CreateAmenityInput, createAmenitySchema } from "../lib/amenity.schema";
   ```

2. **Option A: CREATE with `.select()` to return the created record:**
   ```typescript
   "use server";

   import { requireAuth } from "@/app/features/auth/lib/require-auth";
   import { toSupabaseMutationResponse } from "@/lib/supabase-response";
   import { createValidationError } from "@/lib/validation";
   import type { Tables } from "@/supabase/types/database";
   import {
     type CreateAmenityInput,
     createAmenitySchema,
   } from "../lib/amenity.schema";

   export async function createAmenity(data: CreateAmenityInput) {
     // 1. Verify authentication and get Supabase client
     const { supabase, error: authError } = await requireAuth();
     if (authError || !supabase) {
       return {
         data: null,
         error: authError || {
           code: "UNAUTHENTICATED",
           message: "You must be logged in to create an amenity",
           details: "",
           hint: "",
           name: "AuthError",
         },
       };
     }

     // 2. Validate input
     const validationResult = createAmenitySchema.safeParse(data);
     if (!validationResult.success) {
       return {
         data: null,
         error: createValidationError(validationResult.error),
       };
     }

     // 3. Perform database operation
     const result = await supabase
       .from("amenities")
       .insert(validationResult.data)
       .select()
       .single();
     
     return toSupabaseMutationResponse<Tables<"amenities">>(result);
   }
   ```
   **Use when:** You need the created record immediately (e.g., to display in UI, get generated IDs, update local state)

3. **Option B: CREATE without `.select()` for success/failure only:**
   ```typescript
   "use server";

   import { requireAuth } from "@/app/features/auth/lib/require-auth";
   import { toSupabaseMutationResult } from "@/lib/supabase-response";
   import { createValidationError } from "@/lib/validation";
   import {
     type CreateAmenityInput,
     createAmenitySchema,
   } from "../lib/amenity.schema";

   export async function createAmenitySilent(data: CreateAmenityInput) {
     // 1. Verify authentication and get Supabase client
     const { supabase, error: authError } = await requireAuth();
     if (authError || !supabase) {
       return {
         success: false,
         error: authError || {
           code: "UNAUTHENTICATED",
           message: "You must be logged in",
           details: "",
           hint: "",
           name: "AuthError",
         },
       };
     }

     // 2. Validate input
     const validationResult = createAmenitySchema.safeParse(data);
     if (!validationResult.success) {
       return {
         success: false,
         error: createValidationError(validationResult.error),
       };
     }

     // 3. Perform database operation
     const result = await supabase.from("amenities").insert(validationResult.data);
     return toSupabaseMutationResult(result);
   }
   ```
   **Use when:** You don't need the created record back (e.g., bulk operations, fire-and-forget, when you'll refetch data separately)

4. **For bulk inserts (multiple records):**
   ```typescript
   export async function createAmenities(data: CreateAmenityInput[]) {
     // Validate all items
     const validationResults = data.map((item) => createAmenitySchema.safeParse(item));
     const firstError = validationResults.find((r) => !r.success);
     
     if (firstError && !firstError.success) {
       return {
         data: null,
         error: createValidationError(firstError.error),
       };
     }

     const validatedData = validationResults.map((r) => r.data);
     const result = await supabase
       .from("amenities")
       .insert(validatedData)
       .select();
     
     return toSupabaseMutationResponse<Tables<"amenities">[]>(result);
   }
   ```

5. **Key points:**
   - **Always verify authentication first** with `requireAuth()` or `requireAdmin()`
   - **Reuse the returned `supabase` client** - don't import or create a new one
   - **Validate input second** with Zod before any database operation
   - Use the schema's inferred type (`CreateAmenityInput`) for the input parameter
   - Use `safeParse()` not `parse()` - it returns a result object instead of throwing
   - Use `createValidationError()` to format validation errors
   - **Choose based on use case:**
     - Use `.select()` + `toSupabaseMutationResponse<T>()` when you need the created record(s)
     - Skip `.select()` + use `toSupabaseMutationResult()` when you only need success/failure
   - Use `.single()` if you expect one record, or omit it for arrays

### Using CREATE Server Actions in Components

1. **With `.select()` - when you need the created record:**
   ```typescript
   "use client";

   import { useState } from "react";
   import { createAmenity } from "@/app/features/amenities/actions/create-amenity";
   import { hasError, hasData } from "@/lib/supabase-response";
   import { toast } from "sonner";
   import type { CreateAmenityInput } from "@/app/features/amenities/lib/amenity.schema";

   export default function CreateAmenityForm() {
     const [loading, setLoading] = useState(false);

     async function handleSubmit(formData: FormData) {
       setLoading(true);
       
       const data: CreateAmenityInput = {
         amenity_name: formData.get("name") as string,
         amenity_price: formData.get("price") ? Number(formData.get("price")) : null,
       };

       const result = await createAmenity(data);

       if (hasError(result)) {
         // Handles both validation errors and database errors
         toast.error(`Failed to create amenity: ${result.error.message}`);
         setLoading(false);
         return;
       }

       if (hasData(result)) {
         toast.success("Amenity created successfully!");
         console.log("Created:", result.data);
       }
       
       setLoading(false);
     }

     return (
       <form action={handleSubmit}>
         {/* form fields */}
       </form>
     );
   }
   ```

2. **Key points:**
   - Use the schema's inferred type for building form data
   - Error handling works the same for validation and database errors
   - Validation errors have `code: "VALIDATION_ERROR"` if you need to distinguish

### Error Handling

1. **Custom error messages based on error codes (Best Practice):**
   ```typescript
   export async function createAmenity(data: CreateAmenityInput) {
     // 1. Verify authentication first
     const { supabase, error: authError } = await requireAuth();
     if (authError || !supabase) {
       return { data: null, error: authError };
     }

     // 2. Validate input
     const validationResult = createAmenitySchema.safeParse(data);
     if (!validationResult.success) {
       return {
         data: null,
         error: createValidationError(validationResult.error),
       };
     }

     // 3. Perform database operation
     const result = await supabase
       .from("amenities")
       .insert(validationResult.data)
       .select()
       .single();

     if (result.error) {
       // 4. Handle database errors with user-friendly messages
       // Best Practice: Always use error.code to identify errors
       const errorMessage = getCreateErrorMessage(result.error.code);
       return {
         data: null,
         error: { ...result.error, message: errorMessage },
       };
     }

     return toSupabaseMutationResponse<Tables<"amenities">>(result);
   }
   ```

2. **Error message helper (in `lib/error-messages.ts`):**
   ```typescript
   import messages from "@/lib/messages.json";

   export function getCreateErrorMessage(errorCode: string | undefined): string {
     if (!errorCode) {
       return messages.amenities.messages.error.create.unknown;
     }

     const errorMessages: Record<string, string> = {
       "23505": messages.amenities.messages.error.create["23505"], // Duplicate
       "23503": messages.amenities.messages.error.create["23503"], // FK violation
       "23502": messages.amenities.messages.error.create["23502"], // Not null
       "23514": messages.amenities.messages.error.create["23514"], // Check violation
     };

     return errorMessages[errorCode] || messages.amenities.messages.error.create.unknown;
   }
   ```

3. **Common error codes for CREATE operations:**
   - `UNAUTHENTICATED` - User not logged in (from `requireAuth()`)
   - `FORBIDDEN` - User not authorized/not admin (from `requireAdmin()`)
   - `VALIDATION_ERROR` - Zod validation failed (custom code)
   - `23505` - Unique violation (duplicate entry)
   - `23503` - Foreign key violation (referenced record doesn't exist)
   - `23502` - Not null violation (required field missing)
   - `23514` - Check violation (constraint check failed)

4. **Best practices for error handling:**
   - ✅ **Always verify authentication first** with `requireAuth()` or `requireAdmin()`
   - ✅ **Then validate input with Zod** - catch malformed data before hitting the database
   - ✅ **Use `error.code`** to identify specific error types
   - ✅ **Use centralized messages** from `@/lib/messages.json`
   - ❌ **Avoid string matching on `error.message`** - messages can change
   - ❌ **Never import `supabase` directly** - always use the client from auth helpers

## Benefits

* **Secure**: Authentication verified before any operation
* **Efficient**: Single Supabase client per request (connection pooling)
* **Type-safe**: Zod infers TypeScript types from schemas
* **User-friendly**: Validation messages are clear and actionable
* **Consistent**: Same auth + validation pattern across all CREATE operations
* **Maintainable**: Centralized auth helpers, messages, and schemas per feature
