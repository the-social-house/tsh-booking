---
globs: *.ts
alwaysApply: false
---
## UPDATE Server Actions

These guidelines are specifically for **UPDATE** server actions that modify existing records in Supabase.

Whenever you are tasked with creating a new **UPDATE** Server Action file, use the following guideline/principles

## Basic Requirements

* Always declare `"use server"` in the first line of every Server Action file.

* Always create a separate file for each server action in the following directory structure: `app/features/<feature-name>/actions/update-<entity-name>.ts`

* **Always use `requireAuth()` or `requireAdmin()`** for authentication and to get the Supabase client.

* **Always validate input with Zod** before performing database operations.

## Authentication Protocol

All UPDATE server actions MUST verify authentication before performing any database operations.

### 1. Import and Use Auth Helpers

```typescript
import { requireAuth } from "@/app/features/auth/lib/require-auth";
// OR for admin-only actions:
import { requireAdmin } from "@/app/features/auth/lib/require-admin";
```

### 2. Authentication Check Pattern

```typescript
export async function updateEntity(id: number, data: UpdateEntityInput) {
  // 1. Verify authentication and get Supabase client (ALWAYS first)
  const { supabase, error: authError } = await requireAuth();
  if (authError || !supabase) {
    return {
      data: null,
      error: authError || {
        code: "UNAUTHENTICATED",
        message: "You must be logged in to perform this action",
        details: "",
        hint: "",
        name: "AuthError",
      },
    };
  }

  // 2. Validate ID and input with Zod
  // 3. Perform database operation using the returned supabase client
  // ...
}
```

### 3. Key Points

- **`requireAuth()`** returns `{ user, supabase, error }` - use for user actions
- **`requireAdmin()`** returns `{ user, supabase, error }` - use for admin-only actions
- **Reuse the returned `supabase` client** - don't create a new one
- **Auth check comes BEFORE validation** - no point validating if user isn't authenticated
- **One Supabase client per request** - efficient connection pooling

## Zod Validation Protocol

Server-side validation is **mandatory** for all UPDATE operations. This includes validating both the ID and the update data.

### 1. Create Schemas for the Feature

Create schemas in the feature's lib folder: `app/features/<feature-name>/lib/<entity>.schema.ts`

```typescript
import { z } from "zod";
import messages from "@/lib/messages.json";

/**
 * Schema for validating IDs (used for update/delete)
 */
export const deleteAmenitySchema = z.object({
  id: z
    .number()
    .int(messages.amenities.validation.id.integer)
    .positive(messages.amenities.validation.id.positive),
});

/**
 * Schema for updating an amenity (all fields optional)
 */
export const updateAmenitySchema = z.object({
  amenity_name: z
    .string()
    .min(1, messages.amenities.validation.name.required)
    .min(2, messages.amenities.validation.name.minLength)
    .max(100, messages.amenities.validation.name.maxLength)
    .trim()
    .optional(),
  amenity_price: z
    .number()
    .min(0, messages.amenities.validation.price.min)
    .max(99_999.99, messages.amenities.validation.price.max)
    .nullable()
    .optional(),
});

export type UpdateAmenityInput = z.infer<typeof updateAmenitySchema>;
```

**Key points for update schemas:**
- Make all fields `.optional()` since partial updates are common
- Reuse the ID validation schema (`deleteAmenitySchema`) for validating IDs
- Keep the same validation rules as create, just make fields optional

### 2. Implement Authentication and Validation in Server Action

```typescript
"use server";

import type { PostgrestError } from "@supabase/supabase-js";
import { requireAuth } from "@/app/features/auth/lib/require-auth";
import messages from "@/lib/messages.json";
import { toSupabaseMutationResponse } from "@/lib/supabase-response";
import { createValidationError } from "@/lib/validation";
import type { Tables } from "@/supabase/types/database";
import {
  deleteAmenitySchema,
  type UpdateAmenityInput,
  updateAmenitySchema,
} from "../lib/amenity.schema";
import { getUpdateErrorMessage } from "../lib/error-messages";

export async function updateAmenity(id: number, data: UpdateAmenityInput) {
  // 1. Verify authentication and get Supabase client (ALWAYS first)
  const { supabase, error: authError } = await requireAuth();
  if (authError || !supabase) {
    return {
      data: null,
      error: authError || {
        code: "UNAUTHENTICATED",
        message: "You must be logged in to update an amenity",
        details: "",
        hint: "",
        name: "AuthError",
      },
    };
  }

  // 2. Validate ID
  const idValidation = deleteAmenitySchema.safeParse({ id });
  if (!idValidation.success) {
    return {
      data: null,
      error: createValidationError(idValidation.error),
    };
  }

  // 3. Validate update data
  const dataValidation = updateAmenitySchema.safeParse(data);
  if (!dataValidation.success) {
    return {
      data: null,
      error: createValidationError(dataValidation.error),
    };
  }

  // 4. Perform database operation with validated data
  const validatedData = dataValidation.data;
  const result = await supabase
    .from("amenities")
    .update(validatedData)
    .eq("amenity_id", id)
    .select()
    .single();

  // 5. Handle database errors
  if (result.error) {
    const errorMessage = getUpdateErrorMessage(result.error.code);
    return {
      data: null,
      error: { ...result.error, message: errorMessage },
    };
  }

  // 6. Handle not found case
  if (!result.data) {
    const notFoundError: PostgrestError = {
      code: "PGRST116",
      message: messages.amenities.messages.error.update.notFound,
      details: "",
      hint: "",
    } as PostgrestError;
    return { data: null, error: notFoundError };
  }

  return toSupabaseMutationResponse<Tables<"amenities">>(result);
}
```

## Supabase Response Pattern for UPDATE Operations

Supabase UPDATE operations return `{ data, error, status, statusText }` where:
- `data` contains the updated record(s) **ONLY if** `.select()` is used
- `data` is `null` if `.select()` is **NOT** used (even on successful update)
- `error` is `null` on success, or a `PostgrestError` on failure
- `status` and `statusText` are HTTP response properties (e.g., `status: 200, statusText: "OK"`)
- If no rows match the filter, `data` is `null` and `error` is `null` (successful but no updates)

**Choose based on your use case:**
- **With `.select()`**: Returns the updated record(s) - use when you need the data immediately (e.g., to display in UI, get computed fields)
- **Without `.select()`**: Returns success/failure only - use when you don't need the updated data back (e.g., bulk updates, status changes)

### Server Action Implementation

1. **Import required utilities:**
   ```typescript
   import { requireAuth } from "@/app/features/auth/lib/require-auth";
   // OR for admin-only actions:
   import { requireAdmin } from "@/app/features/auth/lib/require-admin";
   import { toSupabaseMutationResponse } from "@/lib/supabase-response";
   import { createValidationError } from "@/lib/validation";
   import type { Tables } from "@/supabase/types/database";
   import {
     deleteAmenitySchema,
     type UpdateAmenityInput,
     updateAmenitySchema,
   } from "../lib/amenity.schema";
   ```

2. **Option A: UPDATE with `.select()` to return the updated record:**
   ```typescript
   "use server";

   import type { PostgrestError } from "@supabase/supabase-js";
   import { requireAuth } from "@/app/features/auth/lib/require-auth";
   import messages from "@/lib/messages.json";
   import { toSupabaseMutationResponse } from "@/lib/supabase-response";
   import { createValidationError } from "@/lib/validation";
   import type { Tables } from "@/supabase/types/database";
   import {
     deleteAmenitySchema,
     type UpdateAmenityInput,
     updateAmenitySchema,
   } from "../lib/amenity.schema";
   import { getUpdateErrorMessage } from "../lib/error-messages";

   export async function updateAmenity(id: number, data: UpdateAmenityInput) {
     // 1. Verify authentication and get Supabase client
     const { supabase, error: authError } = await requireAuth();
     if (authError || !supabase) {
       return { data: null, error: authError };
     }

     // 2. Validate ID
     const idValidation = deleteAmenitySchema.safeParse({ id });
     if (!idValidation.success) {
       return { data: null, error: createValidationError(idValidation.error) };
     }

     // 3. Validate update data
     const dataValidation = updateAmenitySchema.safeParse(data);
     if (!dataValidation.success) {
       return { data: null, error: createValidationError(dataValidation.error) };
     }

     // 4. Perform database operation
     const result = await supabase
       .from("amenities")
       .update(dataValidation.data)
       .eq("amenity_id", id)
       .select()
       .single();

     if (result.error) {
       const errorMessage = getUpdateErrorMessage(result.error.code);
       return { data: null, error: { ...result.error, message: errorMessage } };
     }

     if (!result.data) {
       const notFoundError = {
         code: "PGRST116",
         message: messages.amenities.messages.error.update.notFound,
         details: "",
         hint: "",
       } as PostgrestError;
       return { data: null, error: notFoundError };
     }
     
     return toSupabaseMutationResponse<Tables<"amenities">>(result);
   }
   ```
   **Use when:** You need the updated record immediately (e.g., to display in UI, get computed fields, update local state)

3. **Option B: UPDATE without `.select()` for success/failure only:**
   ```typescript
   "use server";

   import { requireAuth } from "@/app/features/auth/lib/require-auth";
   import { toSupabaseMutationResult } from "@/lib/supabase-response";
   import { createValidationError } from "@/lib/validation";
   import {
     deleteAmenitySchema,
     type UpdateAmenityInput,
     updateAmenitySchema,
   } from "../lib/amenity.schema";

   export async function updateAmenityStatus(id: number, data: UpdateAmenityInput) {
     // 1. Verify authentication and get Supabase client
     const { supabase, error: authError } = await requireAuth();
     if (authError || !supabase) {
       return { success: false, error: authError };
     }

     // 2. Validate ID
     const idValidation = deleteAmenitySchema.safeParse({ id });
     if (!idValidation.success) {
       return { success: false, error: createValidationError(idValidation.error) };
     }

     // 3. Validate update data
     const dataValidation = updateAmenitySchema.safeParse(data);
     if (!dataValidation.success) {
       return { success: false, error: createValidationError(dataValidation.error) };
     }

     // 4. Perform database operation
     const result = await supabase
       .from("amenities")
       .update(dataValidation.data)
       .eq("amenity_id", id);
     
     return toSupabaseMutationResult(result);
   }
   ```
   **Use when:** You don't need the updated record back (e.g., bulk status updates, when you'll refetch data separately)

4. **For bulk updates (multiple records):**
   ```typescript
   export async function updateAmenities(ids: number[], data: UpdateAmenityInput) {
     // Validate all IDs
     for (const id of ids) {
       const idValidation = deleteAmenitySchema.safeParse({ id });
       if (!idValidation.success) {
         return { data: null, error: createValidationError(idValidation.error) };
       }
     }

     // Validate update data
     const dataValidation = updateAmenitySchema.safeParse(data);
     if (!dataValidation.success) {
       return { data: null, error: createValidationError(dataValidation.error) };
     }

     const result = await supabase
       .from("amenities")
       .update(dataValidation.data)
       .in("amenity_id", ids)
       .select();
     
     return toSupabaseMutationResponse<Tables<"amenities">[]>(result);
   }
   ```

5. **Key points:**
   - **Always verify authentication first** with `requireAuth()` or `requireAdmin()`
   - **Reuse the returned `supabase` client** - don't import or create a new one
   - **Then validate both ID and data** before any database operation
   - Use `deleteAmenitySchema` (or a shared ID schema) for ID validation
   - Use `UpdateAmenityInput` for the update data parameter type
   - Always include the record ID as a separate parameter
   - Use `.eq()` to filter by the primary key, or `.in()` for multiple records
   - **Choose based on use case:**
     - Use `.select()` + `toSupabaseMutationResponse<T>()` when you need the updated record(s)
     - Skip `.select()` + use `toSupabaseMutationResult()` when you only need success/failure
   - Use `.single()` if you expect one record, or omit it for arrays
   - Handle "not found" cases explicitly

### Using UPDATE Server Actions in Components

1. **With `.select()` - when you need the updated record:**
   ```typescript
   "use client";

   import { useState } from "react";
   import { updateAmenity } from "@/app/features/amenities/actions/update-amenity";
   import { hasError, hasData } from "@/lib/supabase-response";
   import { toast } from "sonner";
   import type { UpdateAmenityInput } from "@/app/features/amenities/lib/amenity.schema";

   export default function EditAmenityForm({ amenityId }: { amenityId: number }) {
     const [loading, setLoading] = useState(false);

     async function handleSubmit(formData: FormData) {
       setLoading(true);
       
       const data: UpdateAmenityInput = {
         amenity_name: formData.get("name") as string,
         amenity_price: formData.get("price") ? Number(formData.get("price")) : null,
       };

       const result = await updateAmenity(amenityId, data);

       if (hasError(result)) {
         // Handles validation errors, not found, and database errors
         toast.error(`Failed to update amenity: ${result.error.message}`);
         setLoading(false);
         return;
       }

       if (!hasData(result)) {
         toast.error("Amenity not found");
         setLoading(false);
         return;
       }

       toast.success("Amenity updated successfully!");
       console.log("Updated:", result.data);
       setLoading(false);
     }

     return (
       <form action={handleSubmit}>
         {/* form fields */}
       </form>
     );
   }
   ```

2. **Key points:**
   - Use `UpdateAmenityInput` for type-safe form data
   - Error handling works the same for validation and database errors
   - Validation errors have `code: "VALIDATION_ERROR"` if you need to distinguish
   - Always handle the "not found" case

### Error Handling

1. **Error message helper (in `lib/error-messages.ts`):**
   ```typescript
   import messages from "@/lib/messages.json";

   export function getUpdateErrorMessage(errorCode: string | undefined): string {
     if (!errorCode) {
       return messages.amenities.messages.error.update.unknown;
     }

     const errorMessages: Record<string, string> = {
       "PGRST116": messages.amenities.messages.error.update.notFound,
       "23505": messages.amenities.messages.error.update["23505"], // Duplicate
       "23503": messages.amenities.messages.error.update["23503"], // FK violation
       "23514": messages.amenities.messages.error.update["23514"], // Check violation
     };

     return errorMessages[errorCode] || messages.amenities.messages.error.update.unknown;
   }
   ```

2. **Common error codes for UPDATE operations:**
   - `UNAUTHENTICATED` - User not logged in (from `requireAuth()`)
   - `FORBIDDEN` - User not authorized/not admin (from `requireAdmin()`)
   - `VALIDATION_ERROR` - Zod validation failed (custom code)
   - `PGRST116` - No rows returned (record not found)
   - `23505` - Unique violation (duplicate entry)
   - `23503` - Foreign key violation (referenced record doesn't exist)
   - `23514` - Check violation (constraint check failed)

3. **Best practices for error handling:**
   - ✅ **Always verify authentication first** with `requireAuth()` or `requireAdmin()`
   - ✅ **Then validate ID and data with Zod**
   - ✅ **Use `error.code`** to identify specific error types
   - ✅ **Handle "not found" cases** (PGRST116 or null data)
   - ✅ **Use centralized messages** from `@/lib/messages.json`
   - ❌ **Avoid string matching on `error.message`** - messages can change
   - ❌ **Never import `supabase` directly** - always use the client from auth helpers

## Benefits

* **Secure**: Authentication verified before any operation
* **Efficient**: Single Supabase client per request (connection pooling)
* **Type-safe**: Zod infers TypeScript types from schemas
* **User-friendly**: Validation messages are clear and actionable
* **Consistent**: Same auth + validation pattern across all UPDATE operations
* **Maintainable**: Centralized auth helpers, messages, and schemas per feature
